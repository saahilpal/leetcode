# Evaluate Reverse Polish Notation

**Difficulty:** Medium  
**Pattern:** Stack  
**Language:** cpp  
**LeetCode:** https://leetcode.com/problems/evaluate-reverse-polish-notation/

---

## Intuition
Reverse Polish Notation (RPN) is a method of solving arithmetic expressions where the operator comes after its operands.

For example:
`2 3 +`
This means `2 + 3`.

In RPN:

 Every operator is applied to the two most recent operands.
After two operands, there will always be an operator to perform the operation.
The only valid operators are `+`, `-`, `*`, and `/`.
There is no division by zero.
 The given expression is always valid.
 The final result fits within a 32-bit signed integer.

---

## Approach
So in this problem, we have to evaluate the expression such that a b + becomes a + b.

While thinking about how to solve this, using a stack feels like the most natural choice. The stack helps me keep track of all the operands I encounter.

I’ll go through the expression one by one.

Whenever I see a number, I’ll convert it from string to integer using stoi and then push it into the stack.

Whenever I encounter an operator, I’ll pop the top two values from the stack and perform the operation on them.

For + and *, the order doesn’t really matter.
But for - and /, the order is important. Since the stack follows LIFO:

The first value popped is actually the second operand

The second value popped is the first operand

So the operation should be:

first_operand operator second_operand


After calculating the result, I’ll push it back into the stack.

By the time I finish traversing the entire expression, the stack will be left with only one value, and that value will be the final answer.

---

## Example Walkthrough
Let
t = ["2", "1", "+", "3", "*"]
and initially the stack is empty.

stack = {}


Now I scan the array from left to right.

I see "2" → it’s a number
Convert it using stoi and push into the stack

stack = {2}


I see "1" → it’s also a number
Push it into the stack

stack = {2, 1}


I see "+" → it’s an operator
Pop the top two elements from the stack:

a = top() → 1 (pop)
b = top() → 2 (pop)


Perform the operation:

b + a = 2 + 1 = 3


Push the result back into the stack:

stack = {3}


I move forward and see "3" → it’s a number
Push it into the stack

stack = {3, 3}


I see "*" → it’s an operator
Pop the top two elements:

a = top() → 3 (pop)
b = top() → 3 (pop)


Perform the operation:

b * a = 3 * 3 = 9


Push the result back into the stack:

stack = {9}


Now there is nothing left to scan.
The stack contains only one value, which is the final answer.

Result = 9

---

## Time Complexity
O(n)

---

## Space Complexity
O(n)

---

## Code

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;

        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+") {
                int a = st.top(); st.pop();
                int b = st.top(); st.pop();
                st.push(b + a);
            }
            else if (tokens[i] == "-") {
                int a = st.top(); st.pop();
                int b = st.top(); st.pop();
                st.push(b - a);
            }
            else if (tokens[i] == "*") {
                int a = st.top(); st.pop();
                int b = st.top(); st.pop();
                st.push(b * a);
            }
            else if (tokens[i] == "/") {
                int a = st.top(); st.pop();
                int b = st.top(); st.pop();
                st.push(b / a);
            }
            else {
                st.push(stoi(tokens[i]));
            }
        }
        return st.top();
    }
};
```