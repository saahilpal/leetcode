# Valid Parentheses

**Difficulty:** Easy  
**Pattern:** Stack  
**Language:** cpp  
**LeetCode:** https://leetcode.com/problems/valid-parentheses/description/

---

## Intuition
In the valid parentheses problem, we are given only opening brackets (, {, [ and their corresponding closing brackets. A string is valid if every opening bracket is closed by the same type of bracket and in the correct order. This means a bracket must close the most recently opened one, not an earlier or different type. For example, ([{}]) is valid because each opening bracket has a matching closing bracket in the correct sequence, while (()] is invalid because the last closing bracket does not match the expected one. Also, a closing bracket should never appear before a corresponding opening bracket. At the end, all opening brackets must be closed, otherwise the string is invalid.

---

## Approach
For this problem, I use a stack to track the expected closing brackets. Whenever I encounter an opening bracket like (, {, or [, I push its corresponding closing bracket ), }, or ] onto the stack. This way, the stack always stores what I expect to see next. When a closing bracket appears, I check the top of the stack: if the stack is empty or the current character does not match the top element, the parentheses are invalid and I return false. If it matches, I pop the top element. Since a stack works in LIFO order, the most recently opened bracket must be closed first. After processing the entire string, if the stack is empty, it means all opening brackets were properly closed and the string is valid. If the stack is not empty (for example, when only opening brackets are present), it correctly returns false.

---

## Example Walkthrough
input: s = "()[]"

Initialize an empty stack st.

Read first character '('
Push its expected closing bracket ')' into the stack.
st = { ')' }

Read next character ')'
Compare with st.top() → they match.
Pop the stack.
st = { }

Read next character '['
Push its expected closing bracket ']' into the stack.
st = { ']' }

Read next character ']'
Compare with st.top() → they match.
Pop the stack.
st = { }

All characters are processed.
The stack is empty, meaning all opening brackets were properly closed.

Return st.empty() → true

---

## Time Complexity
o(n)

---

## Space Complexity
O(n) due to the stack used for unmatched opening brackets.

---

## Code

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char>st;
        for(char& p:s)
        {
            if(p=='(')
            st.push(')');
            else if(p=='{')
            st.push('}');
            else if(p=='[')
            st.push(']');
            else
            {
                if(st.empty()||p!=st.top())
                return false;
                st.pop();
            }
        }
        return st.empty();
    }
};
```
