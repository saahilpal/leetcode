# Min Stack

**Difficulty:** Medium  
**Pattern:** Stack  
**Language:** cpp  
**LeetCode:** https://leetcode.com/problems/min-stack/description/

---

## Intuition
I need to design a stack that supports `push`, `pop`, `top`, and `getMin` in constant time. A `vector` works well for stack operations since `push_back`, `pop_back`, and `back` are O(1). However, getting the minimum cannot be done in O(1) using a vector alone, so the minimum value must be tracked separately during operations to ensure all functions run in constant time.

---

## Approach
Here is a **small, clear, human-level** version of your approach, cleaned up but keeping *your* logic:

I use two stacks: `st` to store all elements and `stMin` to track the minimum value. On every push, I push the value into `st`, and for efficiency I only push into `stMin` when the stack is empty or the current value is smaller than or equal to the current minimum (`stMin.back()`). While popping, I first check if the top of `st` is equal to the top of `stMin`; if so, I pop from both stacks, otherwise only from `st`. The top element is obtained using `st.back()` and the minimum element using `stMin.back()`, ensuring all operations run in O(1) time.

---

## Example Walkthrough
We use two stacks:

st → stores all values

stMin → stores only the current minimum values

Push 0

st = {0}

stMin = {0}
Since the stack is empty, 0 is the minimum.

Push 1

st = {0, 1}

stMin = {0}
1 is greater than the current minimum (0), so we do not add it to stMin.

Push -1

st = {0, 1, -1}

stMin = {0, -1}
-1 is smaller than the current minimum (0), so we push it into stMin.

Pop

st.back() = -1

stMin.back() = -1
Since both are equal, we pop from both stacks.

After pop:

st = {0, 1}

stMin = {0}

Top

top = st.back() = 1

GetMin

min = stMin.back() = 0

---

## Time Complexity
o(1)

---

## Space Complexity
o(n)

---

## Code

```cpp
class MinStack {
private:
    vector<int> st;
    vector<int> stmin;

public:
    MinStack() {}

    void push(int val) {
        st.push_back(val);
        if (stmin.empty() || val <= stmin.back())
            stmin.push_back(val);
    }

    void pop() {
        if (st.back() == stmin.back()) {
            stmin.pop_back();
        }
        st.pop_back();
    }

    int top() { return st.back(); }

    int getMin() { return stmin.back(); }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```