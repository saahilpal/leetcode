# Find Minimum In Rotated Sorted Array

**Difficulty:** Medium  
**Pattern:** Binary Search  
**Language:** cpp  
**LeetCode:** https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

---

## Intuition
If the array is rotated, then the smallest element would lie on the right side.

---

## Approach
Since the array is already sorted and the problem requires an O(log n) time algorithm, the core idea is to use binary search.

I compare the middle element with the last element:

If the middle element is greater than the last element, then the smallest element must lie in the right half (from mid + 1 to high).

If the middle element is less than or equal to the last element, then the smallest element lies in the left half (from low to mid).

By repeatedly narrowing the search space this way, eventually low will point to the smallest element in the array.

---

## Example Walkthrough
Letâ€™s walk through an example:
[3, 4, 5, 1, 2]
low = 0, high = 4

We compute mid = 2.
nums[mid] = 5, nums[high] = 2.

Since nums[mid] > nums[high], the minimum must lie in the right half,
so we move low = mid + 1 = 3.

Now the range is [1, 2] (indices 3 to 4).
We again compute the middle: mid = 3.
nums[mid] = 1, nums[high] = 2.

Since nums[mid] <= nums[high], the right part is sorted,
so the minimum lies at mid or to the left.
We move high = mid = 3.

Now low = 3 and high = 3, so the loop stops.
The smallest element is nums[3] = 1.

---

## Time Complexity
o(log n)

---

## Space Complexity
o(1)

---

## Code

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left=0,right=nums.size()-1;
        while(left<right)
        {
            int mid=left+(right-left)/2;
            if(nums[mid]>nums[right])
            {
                left=mid+1; 
            }
            else
            right=mid;
        }
        return nums[left];
        
    }
};
```