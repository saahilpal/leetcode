# Time Based Key Value Store

**Difficulty:** Medium  
**Pattern:** Binary Search  
**Language:** cpp  
**LeetCode:** https://leetcode.com/problems/time-based-key-value-store/

---

## Intuition
For each key, multiple values exist at different timestamps.
The goal is to return the value with the largest timestamp less than or equal to the given timestamp.
Since timestamps are strictly increasing, we can store values in order and use binary search to efficiently find the answer.

---

## Approach
I use an unordered_map where each key maps to a vector of (timestamp, value) pairs.

In the set function, I simply append the pair using push_back because timestamps are always increasing.

In the get function:

If the key doesn’t exist, I return an empty string.

Otherwise, I perform a rightmost binary search to find the largest timestamp ≤ target.

When mid.timestamp ≤ target, I store it as a candidate and move right to find a better one.

This results in O(log n) time for get and O(1) for set.

---

## Example Walkthrough
After set operation 
set("foo", "bar", 1)
set("foo", "bar2", 4)
this will look like foo =[(1,bar1),(4,bar2)]
get("foo", 3)
I need to find the value whose timestamp is less than or equal to 3 and as large as possible.

Timestamp 4 is greater than 3, so it cannot be used.

Timestamp 1 is less than or equal to 3, so it is a valid candidate.

The largest timestamp ≤ 3 is 1, so I return the value "bar". which <=3 is 1 so

---

## Time Complexity
o(log n)

---

## Space Complexity
o(1)

---

## Code

```cpp

class TimeMap {
private:
    unordered_map<string, vector<pair<int, string>>> mp;

public:
    TimeMap() {}

    void set(string key, string value, int timestamp) {
        mp[key].push_back({timestamp, value});
    }

    string get(string key, int timestamp) {
        if (mp.find(key) == mp.end())
            return "";
        auto& arr = mp[key];
        int l = 0, r = arr.size() - 1;
        string ans = "";
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (arr[mid].first <= timestamp){
                ans = arr[mid].second;
                 l = mid + 1;
            }else{ 
            r = mid - 1;
            }
        }
        return ans;
    }
};

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap* obj = new TimeMap();
 * obj->set(key,value,timestamp);
 * string param_2 = obj->get(key,timestamp);
 */
```